//
// Created by sachetto on 29/09/17.
//

#ifndef MONOALG3D_CELL_H
#define MONOALG3D_CELL_H

#include <stdlib.h>
#include <stdbool.h>
#include <stdint.h>

struct basic_cell_data {
    char type;
    uint8_t  level; //This should be enough for the refinement levels
    float center_x, center_y, center_z; //TODO: @Check: always positive integer???
};

struct cell_node {

    struct basic_cell_data cell_data;

    uint8_t active;

    uint64_t bunch_number; // Bunch identifier

    union cell *north; // Points to cell node or transition node above this cell. Z right
    union cell *south; // Points to cell node or transition node below this cell. Z left
    union cell *east;  // Points to cell node or transition node rightward this cell.Y right
    union cell *west;  // Points to cell node or transition node leftward this cell. Y left
    union cell *front; // Points to cell node or transition node in front of this cell. X right
    union cell *back;  // Points to cell node or transition node behind this cell. X left

    struct cell_node *previous; // Previous cell in the Hilbert curve ordering.
    struct cell_node *next;     // Next cell of in the Hilbert curve ordering.

    // Indicates position of cell on grid according to  ordering provided by
    // the modified Hilbert curve.
    uint64_t grid_position;

    // Variable used to storage the form of the  Hilbert curve in the  bunch
    // created when this cell is refined.
    int8_t hilbert_shape_number;

    // Cell geometry.
    float half_face_length;

    // Fluxes used to decide if a cell should be refined or if a bunch
    // should be derefined.
    float   north_flux, // Flux coming from north direction.
            south_flux, // Flux coming from south direction.
            east_flux,  // Flux coming from east direction.
            west_flux,  // Flux coming from west direction.
            front_flux, // Flux coming from front direction.
            back_flux;  // Flux coming from back direction.

    //______________________________________________________________________________
    /* First element in the row of the grid discretization matrix generated by this cell.
       Remember that matrix rows are implemented as linked lists. This firstElement
       corresponds to the diagonal element of the row. */

    // Element *firstElement; //TODO: @Check: I dont't know with we need a linked list here

    //______________________________________________________________________________
    /* Variables used in solving the discretized system Ax = b through the conjugate gradient method.
   The grid discretization matrix and its resolution are directly implemented on the grid,
   which improves performance. There is no independent linear algebra package. */
    double Ax;  /* Element of vector Ax = b associated to this cell. Also plays the role of Ap.*/
    double r;   /* Element of the vector r = b - Ax associated to this cell. */
    double p;   /* Element of the search direction vector in the conjugate gradient algorithm. */
    double p1;  /* p's upgrade in the conjugate gradient algorithm. */
    double z;  //Jacobi preconditioner
    double b;   /* In Ax = b, corresponds to the element in vector b associated to this cell. */

    //pthread_mutex_t updating; //TODO: @Incomplete: implement the mutex

    // Variables used by some applications of partial differential equations.
    double v;
    uint64_t gpu_sv_position;
    float face_length;
    uint8_t can_change;

    //ode *od; //TODO: @Incomplete: implement the ode's handling

    uint8_t fibrotic;
    uint8_t border_zone;
    char scar_type;

};

struct transition_node {

    struct basic_cell_data cell_data;

    union cell *single_connector;
    union cell *quadruple_connector1;
    union cell *quadruple_connector2;
    union cell *quadruple_connector3;
    union cell *quadruple_connector4;

    /* Directions that a transition node may assume:
     * 'e': east
     * 'w': west
     * 'n': north
     * 's': south
     * 'f': front
     * 'b': back
     */
    char direction;
};

union cell {
    struct cell_node *cell_node;
    struct transition_node *transition_node;
};


void init_basic_cell_data(struct basic_cell_data *data, char type,
                                      uint8_t level, float center_x,float center_y,
                                      float center_z);

void init_basic_cell_data_with_default_values(struct basic_cell_data *data, char type);

void init_cell_node(struct cell_node *cell_node, uint8_t init_ode);

void free_cell_node(struct cell_node *cell_node);

void init_cell_node_ode(struct cell_node *cell_node);

void lock_cell_node(struct cell_node *cell_node1);

void unlock_cell_node(struct cell_node *cell_node1);

void init_transition_node(struct transition_node *transition_node);


#endif //MONOALG3D_CELL_H

